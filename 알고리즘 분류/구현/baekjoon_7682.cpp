#include <iostream>
#include <string>
using namespace std;

bool win(const string& s, char p) {
    return (s[0] == p && s[1] == p && s[2] == p) ||
        (s[3] == p && s[4] == p && s[5] == p) ||
        (s[6] == p && s[7] == p && s[8] == p) ||
        (s[0] == p && s[3] == p && s[6] == p) ||
        (s[1] == p && s[4] == p && s[7] == p) ||
        (s[2] == p && s[5] == p && s[8] == p) ||
        (s[0] == p && s[4] == p && s[8] == p) ||
        (s[2] == p && s[4] == p && s[6] == p);
}

int main() {
    while (true) {
        string s;
        cin >> s;
        if (s == "end") break;

        int x = 0, o = 0;
        for (char c : s) {
            if (c == 'X') x++;
            if (c == 'O') o++;
        }

        bool xWin = win(s, 'X');
        bool oWin = win(s, 'O');

        if (xWin && !oWin && x == o + 1) {
            cout << "valid\n";
        }
        else if (!xWin && oWin && x == o) {
            cout << "valid\n";
        }
        else if (!xWin && !oWin && x + o == 9 && x == o + 1) {
            cout << "valid\n";
        }
        else {
            cout << "invalid\n";
        }
    }
    return 0;
}

// 백준 7682번 : 틱택토
// 구현 : 약간의 아이디어가 필요함

// 해당 문제는 입력받은 게임에 따라 가능한 게임인지 불가능한 게임인지 판단하는 문제이다.
// 해당 문제의 핵심은 가능한 경우의 수를 제대로 판단하는 것이다.

// 게임의 룰은 3X3의 바둑판에서 X가 먼저 돌을 두기 시작하여 먼저 1줄을 완성하면 그 즉시 게임이 종료되는 문제이다.\
// 해당 문제에서 주어지는 판이 과연 등장할 수 있는 경우의 수인지 판단하는 문제이다.

// 해당 문제의 핵심은 경우의 수를 잘 판단하는 것이다.
// 1. X가 이기는 경우
// 2. O가 이기는 경우
// 3. 무승부

// X 가 이길 때는 무조건 X가 O보다 하나가 많은 상태에서 끝날 것이다.
// O가 이기는 경우에는 무조건 O의 갯수과 X의 갯수가 같은 상태로 끝날 것이다.
// 만약 무승부로 끝나는 경우는 하나도 만들어 지지 않았을 것이다.

// 해당 조건이 다 포함이 안된다면 정답이 아니다.

// 다만 예외 조건이 있다.
// xoxoxoxox 인 경우 3x3으로 나타내면 아래와 같다. 
// 
// xox
// oxo
// xox

// 해당 경우는 각 꼭짓점에 x가 하나씩 두고 마지막에 가운데에 놓게 되면 생기는 경우의 수이다.
// 또한 해당 경우는 전부 놓았지만 무승부인 경우이다. -> 가능
// xox
// oxo
// oxo

// 해당 예외 조건을 잘 고려한다면 쉽게 풀 수 있던 문제

// 실행시간 : 0ms