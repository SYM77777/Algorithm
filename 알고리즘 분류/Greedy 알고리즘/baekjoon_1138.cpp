#include <iostream>
#include <vector>

using namespace std;

int N;
int out[11] = { 0, };
vector<int> v;


void input() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		int num;
		cin >> num;
		v.push_back(num);
	}
}

void cal() {

	for (int i = 0; i < N; i++) {
		int now = v[i]; // 왼쪽에 와야 하는 인원
		int cnt = 0;
		
		for (int j = 1; j <= N; j++) {
			if (out[j] == 0 && cnt < now) cnt++;
			else if (cnt == now && out[j] == 0) {
				out[j] = i + 1;
				break;
			}
		}
	}

	for (int i = 1; i <= N; i++) cout << out[i] << " ";
}

int main() {

	input();
	cal();

	return 0;
}

// 백준 1138 : 한 줄로 서기
// 구현, 그리디 알고리즘
// 그리디 알고리즘의 대표적인 문제

// 가장 핵심은 주어진 조건이 맞는 첫번째 빈 자리에 넣는 순간 답이 결정된다는 것이다.

// 문제 조건은 아래와 같다.
// 왼쪽에 나보다 큰 키를 가진 사람이 얼마나 있는지를 알려준다.
// 다만 작은 사람이 몇명인지는 안알려줘서 알려준 인덱스 이후로 전부 위치할 수 있어서 한 자리를 특정하는 것이 어려움
// 하지만 주어진 조건에 대한 자리는 이미 고정되어 있다. -> 여러개의 답은 존재하지 않음

// 따라서, 구현 과정을 생각해보면 가장 키가 작은 사람부터 생각해보면 된다.
// 왼쪽에 존재하는 사람은 당연히도 나보다 키가 큰 사람의 수보다는 같거나 작을 것이다.
// 따라서, 주어진 왼쪽에 주어진 값만큼 띈 다음 그 다음칸에 넣으면 된다.
// 하지만, 띈 중간에 나보다 작은 사람이 존재할 수도 있다.
// 따라서! 작은 사람부터 계산하여 자리에 넣고 중간에 존재하는 것이 확인되면 count 를 하지 않는다.
// 그러면 다음 빈칸이 정답이 될 것이다.

// 어떻게 구현하여 답을 바로 얻어낼 지 아이디어를 얻는 것이 중요했던 문제

// 실행 시간 : 0ms



// [그리디 알고리즘이란?]
// "매 순간 최선이라고 생각되는 선택을 하는 알고리즘"
// -> 전체 최적을 구하려고 하지 않고, 지금 이 순간 가장 좋아 보이는 선택을 계속해서 해나가는 방식