#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

void DP(int a) {
	int dp[10001][4] = {0,};
	int ans = 0;

	dp[0][0] = 1;

	for (int k = 1; k <= 3; k++) {
		for (int n = 0; n <= a; n++) {
			dp[n][k] = dp[n][k - 1];  // k를 사용하지 않는 경우
			if (n - k >= 0) {
				dp[n][k] += dp[n - k][k];  // k를 사용하는 경우
			}
		}
	}
	
	ans = dp[a][3];

	cout << ans << "\n";
}

int main() {
	
	int T;
	cin >> T;
	for (int i = 0; i < T; i++) {
		int num;
		cin >> num;
		DP(num);
	}

	return 0;
}

// 15989번 : 1,2,3 더하기 4
// 해당 문제는 중복 조합의 문제로 DP 문제이다.
// 문제를 어떻게 접근해야 되는지 고민을 많이 했던 문제
// 정수 1,2,3을 여러번 사용해도 되지만 같은 양의 숫자를 사용하며 합이 같은 경우는 같은 경우의 수로 처리됨 (중복  조합)
// 중복조합의 기본적인 점화식은 다음과 같다. 
// dp[n][k] = dp[n][k-1] + dp[n-k][k]
// 위 점화식의 의미는 k 이하의 수를 써서 n을 만드는 경우는 k-1 이하의 수를 써서 n을 만드는 경우의 수과 k 이하의 수를 써서 n-k를 만드는 경우의 수의 합이라는 의미이다.
// 해당 점화식을 구할 수 있는 이유는 dp[n][k]는 두 가지 경우로 나뉠 수 있기 떄문이다.
// 1. k를 쓰지 않고 n을 만드는 경우: dp[n][k - 1] // k가 하나도 없음
// 2. k를 최소 1번 쓰고, n - k를 만드는 경우: dp[n - k][k] --> k를 활용하여 만드는 경우의 수

// 따라서, 핵심 아이디어는 n을 만들되, 1~k 까지만 사용해서 만들 수 있는 경우의 수를 세는 것이다!

// 중복 조합의 아이디어를 얻는 것이 핵심이엇던 중요한 문제
// 중복조합의 기본 점화식을 알아두도록 하자! --> dp[n][k] = dp[n][k-1] + dp[n-k][k]

// 실행시간 : 20ms



// 1 / 1
// 1+1 / 2
// 1+1+1 / 1+2 / 3 // 3
// 1+1+1+1 / 2+1+1/ 3+1 / 2+2 // 4
// 1+1+1+1+1 / 2+1+1+1 / 3+1+1 / 2+2+1 / 2+3 // 5
// 1+1+1+1+1+1 / 2+1+1+1+1 / 2+2+1+1 / 3+1+1+1 / 2+2+2 / 3+2+1 / 3+3 // 7
// 1+1+1+1+1+1+1 / 2+1+1+1+1+1 / 2+2+1+1+1 / 3+1+1+1+1 / 2+2+2+1 / 3+2+1+1 / 3+3+1 / 3+2+2 / 8
// 1+1+1+1+1+1+1+1 / 2+1+1+1+1+1+1 / 2+2+1+1+1+1 / 3+1+1+1+1+1 / 2+2+2+1+1 / 3+2+1+1+1 / 2+2+2+2 / 3+2+2+1 / 3+3+1+1 / 3+3+2