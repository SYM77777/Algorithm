#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int H, W;
vector<int> v(501);

int left_max[501];
int right_max[501];

int ans = 0;

void input() {
	cin >> H >> W;
	for (int i = 0; i < W; i++) cin >> v[i];

	left_max[0] = v[0];
	right_max[W - 1] = v[W - 1];

	for (int i = 1; i < W; i++) {
		left_max[i] = max(left_max[i - 1], v[i]);
	}

	for (int i = W - 2; i >= 0; i--) {
		right_max[i] = max(right_max[i + 1], v[i]);
	}
}

void cal() {

	for (int i = 0; i < W; i++) ans += min(left_max[i], right_max[i]) - v[i];

}


int main() {

	input();
	cal();
	cout << ans << "\n";

	return 0;
}

// 백준 14719번 : 빗물
// 주어진 벽의 높이에서 비가 위에서 내렸다고 할때 고일 수 있는 비의 양을 계산하는 구현문제
// 어떻게 구현을 하면 좋을지 아이디어를 얻는 것이 어려웠던 문제였다.

// 결론부터 말하자면 해당 문제의 핵심은 어디에 비가 고일 수 있는가? 를 생각하는 것이다.
// 비가 고일 수 있는 곳은 당연히 "양 옆이 막힌 곳" 일 것이다. -> 즉, 왼쪽과 오른쪽에 자신보다 높은 벽이 존재해야 할 것이다.
// 그럼, "얼마나 높게 쌓일 것인가?" 를 생각해보자. 예를 들어, 2 1 1 2 인 경우에는 2칸 만큼 비가 찰 것이다. 하지만 3 1 1 5 같은 경우는 4칸의 비가 찰 것이다.
// 여기서, 우리는 힌트를 하나 얻을 수 있다. 2 1 1 2의 예시에서 1의 왼쪽으로 가장 큰 벽은 2, 오른쪽으로 가장 큰 벽은 2 이다.
// 마찬가지로 3 1 1 5의 예시에서 1의 왼쪽으로 가장 큰 벽은 3, 오른쪽으로 가장 큰 벽은 5 이다.

// 즉, 현재 위치의 빗물이 고이는 양은 오른쪽의 가장 높은벽과 왼쪽의 가장 높은 벽 중 작은 벽과 자신의 차이 값 만큼 고이게 된다!!!!!
// 해당 사실을 알게 되면 매우 단순한 문제.

// 추가적으로, 왼쪽에서 가장 높은 벽과 오른쪽에서 가장 높은 벽을 각각 배열로 구현하면 된다.
// 왼쪽에서 가장 높은 벽 : 처음 시작은 가장 왼쪽 벽이 가장 높고 index를 하나씩 증가해가며 그 이전값과 비교하면 된다. left_max[i] = max(left_max[i - 1], v[i]);
// 오른쪽에서 가장 높은 벽 : 처음 시작은 가장 오른쪽 벽이 가장 높고 index를 하나씩 감소해가며 그 이전값과 비교하면 된다. right_max[i] = max(right_max[i + 1], v[i]);


// 사고의 흐름이 매우 중요했던 문제
// 누적 최대값을 이용해서 좌우에서 본 정보를 조합하는 방식의 구현 문제이다.
// 유사 문제 : 백준 1244, 프로그래머스 "기둥과 보 설치"

// 실행시간 : 0ms